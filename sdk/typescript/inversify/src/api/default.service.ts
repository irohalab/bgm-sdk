/**
 * Bangumi API
 * 你可以在 <https://api.bgm.tv/v0/oauth/> 生成一个 Access Token  ## 建议客户端开发者指定一个带有 APP 名称和版本的 User Agent，而非使用 HTTP 请求库默认的 UA  各种请求库的默认 UA 在未来可能会被禁用。 
 *
 * The version of the OpenAPI document: 2022-04-20
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs';

import { map } from 'rxjs/operators';
import IHttpClient from '../IHttpClient';
import { inject, injectable } from 'inversify';
import { IAPIConfiguration } from '../IAPIConfiguration';
import { Headers } from '../Headers';
import HttpResponse from '../HttpResponse';

import { CharacterDetail } from '../model/characterDetail';
import { CharacterPerson } from '../model/characterPerson';
import { CollectionStatusType } from '../model/collectionStatusType';
import { CollectionType } from '../model/collectionType';
import { DetailedRevision } from '../model/detailedRevision';
import { EpStatusType } from '../model/epStatusType';
import { EpType } from '../model/epType';
import { EpisodeDetail } from '../model/episodeDetail';
import { ErrorDetail } from '../model/errorDetail';
import { Index } from '../model/index';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InlineResponse2003 } from '../model/inlineResponse2003';
import { InlineResponse2004 } from '../model/inlineResponse2004';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { Me } from '../model/me';
import { PagedEpisode } from '../model/pagedEpisode';
import { PagedIndexSubject } from '../model/pagedIndexSubject';
import { PagedRevision } from '../model/pagedRevision';
import { PagedUserCollection } from '../model/pagedUserCollection';
import { PersonCharacter } from '../model/personCharacter';
import { PersonDetail } from '../model/personDetail';
import { PersonRevision } from '../model/personRevision';
import { PolApiV0ModelsRelatedSubject } from '../model/polApiV0ModelsRelatedSubject';
import { PolApiV0ModelsSubjectRelatedSubject } from '../model/polApiV0ModelsSubjectRelatedSubject';
import { RelatedCharacter } from '../model/relatedCharacter';
import { RelatedPerson } from '../model/relatedPerson';
import { ResponseGroup } from '../model/responseGroup';
import { StatusCode } from '../model/statusCode';
import { Subject1 } from '../model/subject1';
import { SubjectRevision } from '../model/subjectRevision';
import { SubjectType } from '../model/subjectType';
import { SubjectType1 } from '../model/subjectType1';
import { SubjectTypeName } from '../model/subjectTypeName';
import { User } from '../model/user';

import { COLLECTION_FORMATS }  from '../variables';
import { DefaultServiceInterface }  from './default.serviceInterface';



@injectable()
export class DefaultService implements DefaultServiceInterface {
    private basePath: string = 'https://api.bgm.tv';

    constructor(@inject('IApiHttpClient') private httpClient: IHttpClient,
        @inject('IAPIConfiguration') private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * 批量更新收视进度
     * 
     * @param subjectId 条目 ID
     * @param watchedEps 如看到 123 话则 POST &#x60;123&#x60; &lt;br&gt; 书籍条目传 watched_eps 与 watched_vols 至少其一
     * @param watchedVols 如看到第 3 卷则 POST &#x60;3&#x60;, 仅对书籍条目有效
     
     */
    public batchUpdateEpisodeStatusBySubjectId(subjectId: number, watchedEps: string, watchedVols?: string, observe?: 'body', headers?: Headers): Observable<StatusCode>;
    public batchUpdateEpisodeStatusBySubjectId(subjectId: number, watchedEps: string, watchedVols?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<StatusCode>>;
    public batchUpdateEpisodeStatusBySubjectId(subjectId: number, watchedEps: string, watchedVols?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling batchUpdateEpisodeStatusBySubjectId.');
        }

        if (watchedEps === null || watchedEps === undefined){
            throw new Error('Required parameter watchedEps was null or undefined when calling batchUpdateEpisodeStatusBySubjectId.');
        }

        let queryParameters: string[] = [];
        if (watchedEps !== undefined) {
            queryParameters.push('watchedEps='+encodeURIComponent(String(watchedEps)));
        }
        if (watchedVols !== undefined) {
            queryParameters.push('watchedVols='+encodeURIComponent(String(watchedVols)));
        }

        // authentication (HTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<StatusCode>> = this.httpClient.post(`${this.basePath}/subject/${encodeURIComponent(String(subjectId))}/update/watched_eps?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <StatusCode>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 每日放送
     * 
     
     */
    public getCalendar(observe?: 'body', headers?: Headers): Observable<Array<InlineResponse2004>>;
    public getCalendar(observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<InlineResponse2004>>>;
    public getCalendar(observe: any = 'body', headers: Headers = {}): Observable<any> {
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<InlineResponse2004>>> = this.httpClient.get(`${this.basePath}/calendar`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<InlineResponse2004>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Character Detail
     * cache with 60s
     * @param characterId 
     
     */
    public getCharacterById(characterId: number, observe?: 'body', headers?: Headers): Observable<CharacterDetail>;
    public getCharacterById(characterId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<CharacterDetail>>;
    public getCharacterById(characterId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (characterId === null || characterId === undefined){
            throw new Error('Required parameter characterId was null or undefined when calling getCharacterById.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<CharacterDetail>> = this.httpClient.get(`${this.basePath}/v0/characters/${encodeURIComponent(String(characterId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <CharacterDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Character Revision
     * 
     * @param revisionId 
     
     */
    public getCharacterRevisionByRevisionId(revisionId: number, observe?: 'body', headers?: Headers): Observable<DetailedRevision>;
    public getCharacterRevisionByRevisionId(revisionId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<DetailedRevision>>;
    public getCharacterRevisionByRevisionId(revisionId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (revisionId === null || revisionId === undefined){
            throw new Error('Required parameter revisionId was null or undefined when calling getCharacterRevisionByRevisionId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<DetailedRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/characters/${encodeURIComponent(String(revisionId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <DetailedRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Character Revisions
     * 
     * @param characterId 
     * @param limit 
     * @param offset 
     
     */
    public getCharacterRevisions(characterId: number, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedRevision>;
    public getCharacterRevisions(characterId: number, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedRevision>>;
    public getCharacterRevisions(characterId: number, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (characterId === null || characterId === undefined){
            throw new Error('Required parameter characterId was null or undefined when calling getCharacterRevisions.');
        }

        let queryParameters: string[] = [];
        if (characterId !== undefined) {
            queryParameters.push('characterId='+encodeURIComponent(String(characterId)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/characters?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 获取指定条目收藏信息
     * 
     * @param subjectId 条目 ID
     
     */
    public getCollectionBySubjectId(subjectId: number, observe?: 'body', headers?: Headers): Observable<InlineResponse2006>;
    public getCollectionBySubjectId(subjectId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<InlineResponse2006>>;
    public getCollectionBySubjectId(subjectId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getCollectionBySubjectId.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<InlineResponse2006>> = this.httpClient.get(`${this.basePath}/collection/${encodeURIComponent(String(subjectId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <InlineResponse2006>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Episode
     * 
     * @param episodeId 
     
     */
    public getEpisodeById(episodeId: number, observe?: 'body', headers?: Headers): Observable<EpisodeDetail>;
    public getEpisodeById(episodeId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<EpisodeDetail>>;
    public getEpisodeById(episodeId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (episodeId === null || episodeId === undefined){
            throw new Error('Required parameter episodeId was null or undefined when calling getEpisodeById.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<EpisodeDetail>> = this.httpClient.get(`${this.basePath}/v0/episodes/${encodeURIComponent(String(episodeId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <EpisodeDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Episode Revision
     * 
     * @param revisionId 
     
     */
    public getEpisodeRevisionByRevisionId(revisionId: number, observe?: 'body', headers?: Headers): Observable<DetailedRevision>;
    public getEpisodeRevisionByRevisionId(revisionId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<DetailedRevision>>;
    public getEpisodeRevisionByRevisionId(revisionId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (revisionId === null || revisionId === undefined){
            throw new Error('Required parameter revisionId was null or undefined when calling getEpisodeRevisionByRevisionId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<DetailedRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/episodes/${encodeURIComponent(String(revisionId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <DetailedRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Episode Revisions
     * 
     * @param episodeId 
     * @param limit 
     * @param offset 
     
     */
    public getEpisodeRevisions(episodeId: number, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedRevision>;
    public getEpisodeRevisions(episodeId: number, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedRevision>>;
    public getEpisodeRevisions(episodeId: number, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (episodeId === null || episodeId === undefined){
            throw new Error('Required parameter episodeId was null or undefined when calling getEpisodeRevisions.');
        }

        let queryParameters: string[] = [];
        if (episodeId !== undefined) {
            queryParameters.push('episodeId='+encodeURIComponent(String(episodeId)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/episodes?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 更新收视进度
     * 
     * @param id 章节 ID
     * @param status 收视类型，参考 [EpStatusType](#model-EpStatusType)
     
     */
    public getEpisodeStatus(id: number, status: EpStatusType, observe?: 'body', headers?: Headers): Observable<StatusCode>;
    public getEpisodeStatus(id: number, status: EpStatusType, observe?: 'response', headers?: Headers): Observable<HttpResponse<StatusCode>>;
    public getEpisodeStatus(id: number, status: EpStatusType, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling getEpisodeStatus.');
        }

        if (status === null || status === undefined){
            throw new Error('Required parameter status was null or undefined when calling getEpisodeStatus.');
        }

        // authentication (HTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<StatusCode>> = this.httpClient.get(`${this.basePath}/ep/${encodeURIComponent(String(id))}/status/${encodeURIComponent(String(status))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <StatusCode>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Episodes
     * 
     * @param subjectId 
     * @param type 参照章节的&#x60;type&#x60;
     * @param limit 
     * @param offset 
     
     */
    public getEpisodes(subjectId: number, type?: EpType, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedEpisode>;
    public getEpisodes(subjectId: number, type?: EpType, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedEpisode>>;
    public getEpisodes(subjectId: number, type?: EpType, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getEpisodes.');
        }

        let queryParameters: string[] = [];
        if (subjectId !== undefined) {
            queryParameters.push('subjectId='+encodeURIComponent(String(subjectId)));
        }
        if (type !== undefined) {
            queryParameters.push('type='+encodeURIComponent(String(type)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedEpisode>> = this.httpClient.get(`${this.basePath}/v0/episodes?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedEpisode>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Index By Id
     * 
     * @param indexId 
     
     */
    public getIndexById(indexId: number, observe?: 'body', headers?: Headers): Observable<Index>;
    public getIndexById(indexId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Index>>;
    public getIndexById(indexId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (indexId === null || indexId === undefined){
            throw new Error('Required parameter indexId was null or undefined when calling getIndexById.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Index>> = this.httpClient.get(`${this.basePath}/v0/indices/${encodeURIComponent(String(indexId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Index>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Index Subjects
     * 
     * @param indexId 
     * @param type 
     * @param limit 
     * @param offset 
     
     */
    public getIndexSubjectsByIndexId(indexId: number, type?: SubjectType1, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedIndexSubject>;
    public getIndexSubjectsByIndexId(indexId: number, type?: SubjectType1, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedIndexSubject>>;
    public getIndexSubjectsByIndexId(indexId: number, type?: SubjectType1, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (indexId === null || indexId === undefined){
            throw new Error('Required parameter indexId was null or undefined when calling getIndexSubjectsByIndexId.');
        }

        let queryParameters: string[] = [];
        if (type !== undefined) {
            queryParameters.push('type='+encodeURIComponent(String(type)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedIndexSubject>> = this.httpClient.get(`${this.basePath}/v0/indices/${encodeURIComponent(String(indexId))}/subjects?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedIndexSubject>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Person
     * cache with 60s
     * @param personId 
     
     */
    public getPersonById(personId: number, observe?: 'body', headers?: Headers): Observable<PersonDetail>;
    public getPersonById(personId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PersonDetail>>;
    public getPersonById(personId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (personId === null || personId === undefined){
            throw new Error('Required parameter personId was null or undefined when calling getPersonById.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PersonDetail>> = this.httpClient.get(`${this.basePath}/v0/persons/${encodeURIComponent(String(personId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PersonDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Person Revision
     * 
     * @param revisionId 
     
     */
    public getPersonRevisionByRevisionId(revisionId: number, observe?: 'body', headers?: Headers): Observable<PersonRevision>;
    public getPersonRevisionByRevisionId(revisionId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PersonRevision>>;
    public getPersonRevisionByRevisionId(revisionId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (revisionId === null || revisionId === undefined){
            throw new Error('Required parameter revisionId was null or undefined when calling getPersonRevisionByRevisionId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PersonRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/persons/${encodeURIComponent(String(revisionId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PersonRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Person Revisions
     * 
     * @param personId 
     * @param limit 
     * @param offset 
     
     */
    public getPersonRevisions(personId: number, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedRevision>;
    public getPersonRevisions(personId: number, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedRevision>>;
    public getPersonRevisions(personId: number, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (personId === null || personId === undefined){
            throw new Error('Required parameter personId was null or undefined when calling getPersonRevisions.');
        }

        let queryParameters: string[] = [];
        if (personId !== undefined) {
            queryParameters.push('personId='+encodeURIComponent(String(personId)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/persons?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Subject Characters
     * 
     * @param subjectId 
     
     */
    public getRelatedCharactersBySubjectId(subjectId: number, observe?: 'body', headers?: Headers): Observable<Array<RelatedCharacter>>;
    public getRelatedCharactersBySubjectId(subjectId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<RelatedCharacter>>>;
    public getRelatedCharactersBySubjectId(subjectId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getRelatedCharactersBySubjectId.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<RelatedCharacter>>> = this.httpClient.get(`${this.basePath}/v0/subjects/${encodeURIComponent(String(subjectId))}/characters`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<RelatedCharacter>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * get character related persons
     * 
     * @param characterId 
     
     */
    public getRelatedPersonsByCharacterId(characterId: number, observe?: 'body', headers?: Headers): Observable<Array<CharacterPerson>>;
    public getRelatedPersonsByCharacterId(characterId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<CharacterPerson>>>;
    public getRelatedPersonsByCharacterId(characterId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (characterId === null || characterId === undefined){
            throw new Error('Required parameter characterId was null or undefined when calling getRelatedPersonsByCharacterId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<CharacterPerson>>> = this.httpClient.get(`${this.basePath}/v0/characters/${encodeURIComponent(String(characterId))}/persons`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<CharacterPerson>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * get person related characters
     * 
     * @param personId 
     
     */
    public getRelatedPersonsByPersonId(personId: number, observe?: 'body', headers?: Headers): Observable<Array<PersonCharacter>>;
    public getRelatedPersonsByPersonId(personId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<PersonCharacter>>>;
    public getRelatedPersonsByPersonId(personId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (personId === null || personId === undefined){
            throw new Error('Required parameter personId was null or undefined when calling getRelatedPersonsByPersonId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<PersonCharacter>>> = this.httpClient.get(`${this.basePath}/v0/persons/${encodeURIComponent(String(personId))}/characters`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<PersonCharacter>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Subject Persons
     * 
     * @param subjectId 
     
     */
    public getRelatedPersonsBySubjectId(subjectId: number, observe?: 'body', headers?: Headers): Observable<Array<RelatedPerson>>;
    public getRelatedPersonsBySubjectId(subjectId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<RelatedPerson>>>;
    public getRelatedPersonsBySubjectId(subjectId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getRelatedPersonsBySubjectId.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<RelatedPerson>>> = this.httpClient.get(`${this.basePath}/v0/subjects/${encodeURIComponent(String(subjectId))}/persons`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<RelatedPerson>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * get character related subjects
     * 
     * @param characterId 
     
     */
    public getRelatedSubjectsByCharacterId(characterId: number, observe?: 'body', headers?: Headers): Observable<Array<PolApiV0ModelsRelatedSubject>>;
    public getRelatedSubjectsByCharacterId(characterId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<PolApiV0ModelsRelatedSubject>>>;
    public getRelatedSubjectsByCharacterId(characterId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (characterId === null || characterId === undefined){
            throw new Error('Required parameter characterId was null or undefined when calling getRelatedSubjectsByCharacterId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<PolApiV0ModelsRelatedSubject>>> = this.httpClient.get(`${this.basePath}/v0/characters/${encodeURIComponent(String(characterId))}/subjects`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<PolApiV0ModelsRelatedSubject>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * get person related subjects
     * 
     * @param personId 
     
     */
    public getRelatedSubjectsByPersonId(personId: number, observe?: 'body', headers?: Headers): Observable<Array<PolApiV0ModelsRelatedSubject>>;
    public getRelatedSubjectsByPersonId(personId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<PolApiV0ModelsRelatedSubject>>>;
    public getRelatedSubjectsByPersonId(personId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (personId === null || personId === undefined){
            throw new Error('Required parameter personId was null or undefined when calling getRelatedSubjectsByPersonId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<PolApiV0ModelsRelatedSubject>>> = this.httpClient.get(`${this.basePath}/v0/persons/${encodeURIComponent(String(personId))}/subjects`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<PolApiV0ModelsRelatedSubject>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Subject Relations
     * 
     * @param subjectId 
     
     */
    public getRelatedSubjectsBySubjectId(subjectId: number, observe?: 'body', headers?: Headers): Observable<Array<PolApiV0ModelsSubjectRelatedSubject>>;
    public getRelatedSubjectsBySubjectId(subjectId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<PolApiV0ModelsSubjectRelatedSubject>>>;
    public getRelatedSubjectsBySubjectId(subjectId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getRelatedSubjectsBySubjectId.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<PolApiV0ModelsSubjectRelatedSubject>>> = this.httpClient.get(`${this.basePath}/v0/subjects/${encodeURIComponent(String(subjectId))}/subjects`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<PolApiV0ModelsSubjectRelatedSubject>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 条目搜索
     * 
     * @param keywords 关键词 &lt;br&gt; 需要 URL Encode
     * @param type 条目类型，参考 [SubjectType](#model-SubjectType)
     * @param responseGroup 返回数据大小，参考 [ResponseGroup](#model-ResponseGroup) &lt;br&gt; 默认为 small
     * @param start 开始条数
     * @param maxResults 每页条数 &lt;br&gt; 最多 25
     
     */
    public getSearchSubjectBykeywords(keywords: string, type?: SubjectType, responseGroup?: ResponseGroup, start?: number, maxResults?: number, observe?: 'body', headers?: Headers): Observable<InlineResponse2005>;
    public getSearchSubjectBykeywords(keywords: string, type?: SubjectType, responseGroup?: ResponseGroup, start?: number, maxResults?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<InlineResponse2005>>;
    public getSearchSubjectBykeywords(keywords: string, type?: SubjectType, responseGroup?: ResponseGroup, start?: number, maxResults?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (keywords === null || keywords === undefined){
            throw new Error('Required parameter keywords was null or undefined when calling getSearchSubjectBykeywords.');
        }

        let queryParameters: string[] = [];
        if (type !== undefined) {
            queryParameters.push('type='+encodeURIComponent(String(type)));
        }
        if (responseGroup !== undefined) {
            queryParameters.push('responseGroup='+encodeURIComponent(String(responseGroup)));
        }
        if (start !== undefined) {
            queryParameters.push('start='+encodeURIComponent(String(start)));
        }
        if (maxResults !== undefined) {
            queryParameters.push('maxResults='+encodeURIComponent(String(maxResults)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<InlineResponse2005>> = this.httpClient.get(`${this.basePath}/search/subject/${encodeURIComponent(String(keywords))}?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <InlineResponse2005>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 获取条目
     * cache with 300s
     * @param subjectId 
     
     */
    public getSubjectById(subjectId: number, observe?: 'body', headers?: Headers): Observable<Subject1>;
    public getSubjectById(subjectId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Subject1>>;
    public getSubjectById(subjectId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getSubjectById.');
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Subject1>> = this.httpClient.get(`${this.basePath}/v0/subjects/${encodeURIComponent(String(subjectId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Subject1>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Subject Revision
     * 
     * @param revisionId 
     
     */
    public getSubjectRevisionByRevisionId(revisionId: number, observe?: 'body', headers?: Headers): Observable<SubjectRevision>;
    public getSubjectRevisionByRevisionId(revisionId: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<SubjectRevision>>;
    public getSubjectRevisionByRevisionId(revisionId: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (revisionId === null || revisionId === undefined){
            throw new Error('Required parameter revisionId was null or undefined when calling getSubjectRevisionByRevisionId.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<SubjectRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/subjects/${encodeURIComponent(String(revisionId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <SubjectRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get Subject Revisions
     * 
     * @param subjectId 
     * @param limit 
     * @param offset 
     
     */
    public getSubjectRevisions(subjectId: number, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedRevision>;
    public getSubjectRevisions(subjectId: number, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedRevision>>;
    public getSubjectRevisions(subjectId: number, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling getSubjectRevisions.');
        }

        let queryParameters: string[] = [];
        if (subjectId !== undefined) {
            queryParameters.push('subjectId='+encodeURIComponent(String(subjectId)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedRevision>> = this.httpClient.get(`${this.basePath}/v0/revisions/subjects?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedRevision>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get User
     * 返回当前 Access Token 对应的用户信息
     
     */
    public getUser(observe?: 'body', headers?: Headers): Observable<Me>;
    public getUser(observe?: 'response', headers?: Headers): Observable<HttpResponse<Me>>;
    public getUser(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (HTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Me>> = this.httpClient.get(`${this.basePath}/v0/me`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Me>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 用户信息
     * 
     * @param username 用户名 &lt;br&gt; 也可使用 UID
     
     */
    public getUserByUsername(username: string, observe?: 'body', headers?: Headers): Observable<User>;
    public getUserByUsername(username: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<User>>;
    public getUserByUsername(username: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (username === null || username === undefined){
            throw new Error('Required parameter username was null or undefined when calling getUserByUsername.');
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<User>> = this.httpClient.get(`${this.basePath}/user/${encodeURIComponent(String(username))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <User>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 用户收藏统计
     * 
     * @param username 用户名 &lt;br&gt; 也可使用 UID
     * @param appId [https://bgm.tv/dev/app](https://bgm.tv/dev/app) 申请到的 App ID
     
     */
    public getUserCollectionStatusByUsername(username: string, appId: string, observe?: 'body', headers?: Headers): Observable<Array<InlineResponse2002>>;
    public getUserCollectionStatusByUsername(username: string, appId: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<InlineResponse2002>>>;
    public getUserCollectionStatusByUsername(username: string, appId: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (username === null || username === undefined){
            throw new Error('Required parameter username was null or undefined when calling getUserCollectionStatusByUsername.');
        }

        if (appId === null || appId === undefined){
            throw new Error('Required parameter appId was null or undefined when calling getUserCollectionStatusByUsername.');
        }

        let queryParameters: string[] = [];
        if (appId !== undefined) {
            queryParameters.push('appId='+encodeURIComponent(String(appId)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<InlineResponse2002>>> = this.httpClient.get(`${this.basePath}/user/${encodeURIComponent(String(username))}/collections/status?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<InlineResponse2002>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 用户收藏概览
     * 
     * @param username 用户名 &lt;br&gt; 也可使用 UID
     * @param subjectType 条目类型，详见 [SubjectTypeName](#model-SubjectTypeName)
     * @param appId [https://bgm.tv/dev/app](https://bgm.tv/dev/app) 申请到的 App ID
     * @param maxResults 显示条数 &lt;br&gt; 最多 25
     
     */
    public getUserCollectionsBySubjectType(username: string, subjectType: SubjectTypeName, appId: string, maxResults?: number, observe?: 'body', headers?: Headers): Observable<Array<InlineResponse2001>>;
    public getUserCollectionsBySubjectType(username: string, subjectType: SubjectTypeName, appId: string, maxResults?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<InlineResponse2001>>>;
    public getUserCollectionsBySubjectType(username: string, subjectType: SubjectTypeName, appId: string, maxResults?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (username === null || username === undefined){
            throw new Error('Required parameter username was null or undefined when calling getUserCollectionsBySubjectType.');
        }

        if (subjectType === null || subjectType === undefined){
            throw new Error('Required parameter subjectType was null or undefined when calling getUserCollectionsBySubjectType.');
        }

        if (appId === null || appId === undefined){
            throw new Error('Required parameter appId was null or undefined when calling getUserCollectionsBySubjectType.');
        }

        let queryParameters: string[] = [];
        if (appId !== undefined) {
            queryParameters.push('appId='+encodeURIComponent(String(appId)));
        }
        if (maxResults !== undefined) {
            queryParameters.push('maxResults='+encodeURIComponent(String(maxResults)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<InlineResponse2001>>> = this.httpClient.get(`${this.basePath}/user/${encodeURIComponent(String(username))}/collections/${encodeURIComponent(String(subjectType))}?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<InlineResponse2001>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 用户收藏
     * 
     * @param username 用户名 &lt;br&gt; 也可使用 UID
     * @param cat 收藏类型 &lt;br&gt; watching &#x3D; 在看的动画与三次元条目 &lt;br&gt; all_watching &#x3D; 在看的动画三次元与书籍条目
     * @param ids 收藏条目 ID &lt;br&gt; 批量查询收藏状态，将条目 ID 以半角逗号分隔，如 1,2,4,6
     * @param responseGroup medium / small &lt;br&gt; 默认为 medium。small 时不返回条目详细信息
     
     */
    public getUserCollectionsByUsername(username: string, cat: 'watching' | 'all_watching', ids?: string, responseGroup?: 'small' | 'medium', observe?: 'body', headers?: Headers): Observable<Array<InlineResponse200>>;
    public getUserCollectionsByUsername(username: string, cat: 'watching' | 'all_watching', ids?: string, responseGroup?: 'small' | 'medium', observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<InlineResponse200>>>;
    public getUserCollectionsByUsername(username: string, cat: 'watching' | 'all_watching', ids?: string, responseGroup?: 'small' | 'medium', observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (username === null || username === undefined){
            throw new Error('Required parameter username was null or undefined when calling getUserCollectionsByUsername.');
        }

        if (cat === null || cat === undefined){
            throw new Error('Required parameter cat was null or undefined when calling getUserCollectionsByUsername.');
        }

        let queryParameters: string[] = [];
        if (cat !== undefined) {
            queryParameters.push('cat='+encodeURIComponent(String(cat)));
        }
        if (ids !== undefined) {
            queryParameters.push('ids='+encodeURIComponent(String(ids)));
        }
        if (responseGroup !== undefined) {
            queryParameters.push('responseGroup='+encodeURIComponent(String(responseGroup)));
        }

        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<InlineResponse200>>> = this.httpClient.get(`${this.basePath}/user/${encodeURIComponent(String(username))}/collection?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<InlineResponse200>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 获取用户收藏
     * 获取对应用户的收藏，查看私有收藏需要access token。
     * @param username 设置了 username 后无法使用UID
     * @param subjectType 条目类型，默认为全部  具体含义见 [SubjectType](#model-SubjectType)
     * @param type 收藏类型，默认为全部  具体含义见 [CollectionType](#model-CollectionType)
     * @param limit 
     * @param offset 
     
     */
    public getUserCollectionsByUsername1(username: string, subjectType?: SubjectType1, type?: CollectionType, limit?: number, offset?: number, observe?: 'body', headers?: Headers): Observable<PagedUserCollection>;
    public getUserCollectionsByUsername1(username: string, subjectType?: SubjectType1, type?: CollectionType, limit?: number, offset?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<PagedUserCollection>>;
    public getUserCollectionsByUsername1(username: string, subjectType?: SubjectType1, type?: CollectionType, limit?: number, offset?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (username === null || username === undefined){
            throw new Error('Required parameter username was null or undefined when calling getUserCollectionsByUsername1.');
        }

        let queryParameters: string[] = [];
        if (subjectType !== undefined) {
            queryParameters.push('subjectType='+encodeURIComponent(String(subjectType)));
        }
        if (type !== undefined) {
            queryParameters.push('type='+encodeURIComponent(String(type)));
        }
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PagedUserCollection>> = this.httpClient.get(`${this.basePath}/v0/users/${encodeURIComponent(String(username))}/collections?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PagedUserCollection>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 用户收视进度
     * 
     * @param username 用户名 &lt;br&gt; 也可使用 UID
     * @param subjectId 条目 ID &lt;br&gt; 获取指定条目收视进度
     
     */
    public getUserProgressByUsername(username: string, subjectId?: number, observe?: 'body', headers?: Headers): Observable<Array<InlineResponse2003>>;
    public getUserProgressByUsername(username: string, subjectId?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<InlineResponse2003>>>;
    public getUserProgressByUsername(username: string, subjectId?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (username === null || username === undefined){
            throw new Error('Required parameter username was null or undefined when calling getUserProgressByUsername.');
        }

        let queryParameters: string[] = [];
        if (subjectId !== undefined) {
            queryParameters.push('subjectId='+encodeURIComponent(String(subjectId)));
        }

        // authentication (OptionalHTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<InlineResponse2003>>> = this.httpClient.get(`${this.basePath}/user/${encodeURIComponent(String(username))}/progress?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<InlineResponse2003>>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 管理收藏
     * 管理收藏。Content-type必须为multipart/form-data或application/x-www-form-urlencoded，参数都得放在body里。
     * @param subjectId 条目 ID
     * @param action 收藏动作 &lt;br&gt; create &#x3D; 添加收藏 &lt;br&gt; update &#x3D; 更新收藏 &lt;br&gt; 可以统一使用 &#x60;update&#x60;，系统会自动判断需要新建还是更新收藏
     * @param status 
     * @param comment 简评
     * @param tags 标签 &lt;br&gt; 以半角空格分割
     * @param rating 评分 &lt;br&gt; 1-10 &lt;br&gt; 不填默认重置为未评分
     * @param privacy 收藏隐私 &lt;br&gt; 0 &#x3D; 公开 &lt;br&gt; 1 &#x3D; 私密 &lt;br&gt; 不填默认为0
     
     */
    public updateCollectionBySubjectIdWithAction(subjectId: number, action: 'create' | 'update', status: CollectionStatusType, comment?: string, tags?: string, rating?: number, privacy?: number, observe?: 'body', headers?: Headers): Observable<InlineResponse2006>;
    public updateCollectionBySubjectIdWithAction(subjectId: number, action: 'create' | 'update', status: CollectionStatusType, comment?: string, tags?: string, rating?: number, privacy?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<InlineResponse2006>>;
    public updateCollectionBySubjectIdWithAction(subjectId: number, action: 'create' | 'update', status: CollectionStatusType, comment?: string, tags?: string, rating?: number, privacy?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (subjectId === null || subjectId === undefined){
            throw new Error('Required parameter subjectId was null or undefined when calling updateCollectionBySubjectIdWithAction.');
        }

        if (action === null || action === undefined){
            throw new Error('Required parameter action was null or undefined when calling updateCollectionBySubjectIdWithAction.');
        }

        if (status === null || status === undefined){
            throw new Error('Required parameter status was null or undefined when calling updateCollectionBySubjectIdWithAction.');
        }

        // authentication (HTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        if (status !== undefined) {
            formData.append('status', <any>status);
        }
        if (comment !== undefined) {
            formData.append('comment', <any>comment);
        }
        if (tags !== undefined) {
            formData.append('tags', <any>tags);
        }
        if (rating !== undefined) {
            formData.append('rating', <any>rating);
        }
        if (privacy !== undefined) {
            formData.append('privacy', <any>privacy);
        }

        const response: Observable<HttpResponse<InlineResponse2006>> = this.httpClient.post(`${this.basePath}/collection/${encodeURIComponent(String(subjectId))}/${encodeURIComponent(String(action))}`, formData, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <InlineResponse2006>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 更新收视进度
     * 
     * @param id 章节 ID
     * @param status 收视类型，参考 [EpStatusType](#model-EpStatusType)
     * @param epId 使用 POST 批量更新 &lt;br&gt; 将章节以半角逗号分隔，如 &#x60;3697,3698,3699&#x60;。请求时 URL 中的 ep_id 为最后一个章节 ID
     
     */
    public updateEpisodeStatus(id: number, status: EpStatusType, epId?: string, observe?: 'body', headers?: Headers): Observable<StatusCode>;
    public updateEpisodeStatus(id: number, status: EpStatusType, epId?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<StatusCode>>;
    public updateEpisodeStatus(id: number, status: EpStatusType, epId?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling updateEpisodeStatus.');
        }

        if (status === null || status === undefined){
            throw new Error('Required parameter status was null or undefined when calling updateEpisodeStatus.');
        }

        let queryParameters: string[] = [];
        if (epId !== undefined) {
            queryParameters.push('epId='+encodeURIComponent(String(epId)));
        }

        // authentication (HTTPBearer) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<StatusCode>> = this.httpClient.post(`${this.basePath}/ep/${encodeURIComponent(String(id))}/status/${encodeURIComponent(String(status))}?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <StatusCode>(httpResponse.response))
               );
        }
        return response;
    }

}
